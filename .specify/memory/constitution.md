# Evolution of Todo - Phase I Constitution

## Core Principles

### I. Spec-Driven Development (NON-NEGOTIABLE)
All behavior must originate from written specifications. No feature, function, or behavior may be implemented without first being specified in a spec document under `specs/<feature>/spec.md`.

**Requirements:**
- Every feature begins with a specification that defines its purpose, behavior, and acceptance criteria
- Specifications must be reviewed and approved before implementation begins
- All implementation decisions must trace back to specification requirements
- Changes to behavior require specification updates first

### II. No Manual Coding (NON-NEGOTIABLE)
All code must be generated by Claude Code based on approved specifications. Manual code editing is prohibited.

**Requirements:**
- Use Claude Code with Spec-Kit Plus to generate all code
- All changes flow through the specification â†’ plan â†’ tasks â†’ implementation pipeline
- Manual edits to generated code constitute a violation of this principle
- Bug fixes and enhancements must go through the spec-driven process

### III. Clean Architecture
Clear separation between data models, business logic, and user interface. Each layer has defined responsibilities and dependencies flow in one direction.

**Requirements:**
- **Data Layer**: Plain Python dataclasses or models representing domain entities
- **Logic Layer**: Business rules, task management operations, validation
- **UI Layer**: Command-line interface, input parsing, output formatting
- No UI logic in business layer; no business logic in UI layer
- Dependencies flow: UI â†’ Logic â†’ Data (never reversed)

### IV. Deterministic Behavior
The application must produce predictable outputs for identical inputs. Randomness and non-determinism are prohibited unless explicitly specified.

**Requirements:**
- Pure functions where possible (same input â†’ same output)
- Side effects (I/O, state changes) must be isolated and documented
- No hidden global state or shared mutable state
- Task IDs, timestamps, and ordering must be deterministic and testable

### V. Product-Quality CLI UX
The application must feel like a real, usable product with professional command-line user experience.

**Standards:**
- Clear numbered menu options with consistent formatting
- Consistent spacing, alignment, and visual hierarchy
- Status indicators: `[âœ“]` for completed tasks, `[ ]` for pending
- Friendly success messages (e.g., "âœ“ Task added successfully!")
- Clear, actionable error messages (no raw stack traces to users)
- Empty state handling (e.g., "No tasks yet. Add one to get started!")
- Confirmation prompts for destructive actions (delete, clear all)

### VI. Test-First Development (NON-NEGOTIABLE)
Tests must be written and approved before implementation begins. The Red-Green-Refactor cycle is mandatory.

**Process:**
1. Write tests based on specification acceptance criteria
2. Get user approval of tests
3. Run tests - they must fail (RED)
4. Implement code to pass tests (GREEN)
5. Refactor while keeping tests green (REFACTOR)

**Requirements:**
- 100% of specified behavior must have corresponding tests
- Tests must be readable and serve as living documentation
- Integration tests for command-line interface
- Unit tests for business logic
- Edge cases and error conditions must be tested

## Python Code Standards

### Naming Conventions
- **Classes**: PascalCase (e.g., `TaskManager`, `TodoApp`)
- **Functions/Methods**: snake_case (e.g., `add_task`, `mark_complete`)
- **Variables**: snake_case (e.g., `task_list`, `user_input`)
- **Constants**: SCREAMING_SNAKE_CASE (e.g., `MAX_TASKS`, `DEFAULT_STATUS`)
- **Private members**: Leading underscore (e.g., `_tasks`, `_validate()`)

### Code Quality
- Maximum function length: 20 lines (excluding docstrings and blank lines)
- Maximum class length: 200 lines
- Maximum line length: 100 characters
- Meaningful names that express intent (no abbreviations except standard ones)
- Single Responsibility Principle: Each function/class does one thing well

### Documentation
- Docstrings for all public classes, functions, and modules
- Google-style docstring format
- Type hints for all function signatures
- Comments only for explaining "why", not "what" (code should be self-documenting)

### Dependencies
- Python 3.13+ compatible
- Standard library preferred over third-party packages
- Any third-party dependencies must be justified and documented in specification
- Use `pyproject.toml` for dependency management

## Testing Standards

### Test Coverage
- Minimum 90% code coverage
- 100% coverage of public APIs
- All edge cases and error paths must be tested
- Tests must run in under 5 seconds total

### Test Organization
- Mirror source structure: `tests/` reflects `src/` structure
- Test file naming: `test_<module_name>.py`
- Test function naming: `test_<function>_<scenario>_<expected_result>`
- Use `pytest` as the testing framework

### Test Quality
- Each test tests one behavior/assertion
- Tests are independent (can run in any order)
- Use fixtures for test data setup
- No test logic duplication (use helper functions/fixtures)

## Security Standards

### Input Validation
- All user input must be validated and sanitized
- No code execution from user input (no `eval`, `exec`)
- Path traversal protection (no arbitrary file access)
- Input length limits to prevent resource exhaustion

### Error Handling
- Never expose internal implementation details in error messages
- Log security-relevant events (if logging is implemented)
- Fail securely (errors should not leave app in unsafe state)
- No sensitive data in error messages or logs

## Performance Standards

### In-Memory Storage (Phase I)
- Task list operations must be O(n) or better
- App startup time under 100ms
- Command response time under 50ms
- Memory usage grows linearly with task count

### Efficiency
- No unnecessary data copies
- Lazy evaluation where appropriate
- Efficient data structures (lists for ordered tasks, dicts for lookups)

## CLI Interface Standards

### Command Structure
- Clear main menu with numbered options
- Consistent prompt format: `> ` for user input
- Commands are forgiving (accept variations, handle typos gracefully)
- Support for common shortcuts (e.g., 'q' for quit)

### Output Format
- Use box-drawing characters for visual separation (optional but nice)
- Consistent indentation (2 or 4 spaces)
- Color/styling optional but must degrade gracefully
- Table-like alignment for task lists
- Clear section headers

### Error Messages
- Start with "Error: " or "âœ— " prefix
- Explain what went wrong in plain language
- Suggest corrective action when possible
- No technical jargon or stack traces

## Development Workflow

### Specification Phase
1. Create feature specification in `specs/<feature>/spec.md`
2. Define purpose, behavior, acceptance criteria
3. Get user review and approval
4. Run `/sp.clarify` if needed for underspecified areas

### Planning Phase
1. Run `/sp.plan` to create architectural plan in `specs/<feature>/plan.md`
2. Define technical approach, interfaces, data structures
3. Identify risks and mitigation strategies
4. Create ADRs for significant decisions using `/sp.adr`

### Task Generation Phase
1. Run `/sp.tasks` to generate `specs/<feature>/tasks.md`
2. Break plan into small, testable tasks
3. Each task has clear acceptance criteria
4. Tasks are ordered by dependencies

### Implementation Phase
1. For each task: Write tests first (RED)
2. Get user approval of tests
3. Implement to pass tests (GREEN)
4. Refactor while keeping tests green (REFACTOR)
5. Create PHR (Prompt History Record) after completion

### Verification Phase
- All tests pass (pytest exit code 0)
- Code coverage meets standards (â‰¥90%)
- Linting passes (if configured)
- CLI UX manually verified

## Prompt History Records (PHR)

### When to Create PHRs
- After implementation work (code changes, features)
- After planning/architecture discussions
- After debugging sessions
- After spec/task/plan creation
- After multi-step workflows

### PHR Storage
All PHRs stored under `history/prompts/`:
- Constitution changes: `history/prompts/constitution/`
- Feature work: `history/prompts/<feature-name>/`
- General work: `history/prompts/general/`

### PHR Content Requirements
- Full verbatim user input (not truncated)
- Representative assistant output
- Stage (constitution, spec, plan, tasks, red, green, refactor, etc.)
- Files created/modified
- Tests run/added
- Links to related artifacts (specs, ADRs, PRs)

## Architecture Decision Records (ADR)

### When to Create ADRs
Create an ADR when a decision meets ALL criteria:
1. **Impact**: Has long-term consequences (framework, data model, API, security, platform)
2. **Alternatives**: Multiple viable options were considered
3. **Scope**: Cross-cutting and influences system design

### ADR Suggestion Format
When significant decision detected, suggest:
```
ðŸ“‹ Architectural decision detected: [brief-description]
   Document reasoning and tradeoffs? Run `/sp.adr [decision-title]`
```

### ADR Storage
All ADRs stored in: `history/adr/`

## Governance

### Constitution Authority
- This constitution supersedes all other development practices
- All code generation and reviews must verify compliance
- Complexity must be justified against these principles
- Violations must be documented and remediated

### Amendment Process
- Amendments require specification and user approval
- Document rationale for changes
- Update version number and last amended date
- Create ADR for significant constitutional changes

### Compliance
- All tasks must reference relevant constitutional principles
- Claude Code must verify adherence during code generation
- PHRs must note any principle conflicts or deviations
- Regular constitution review during planning phase

**Version**: 1.0.0 | **Ratified**: 2025-12-30 | **Last Amended**: 2025-12-30
